!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.7	//
AEI_get_lan_macaddr	newmain.c	/^void AEI_get_lan_macaddr(Panssenger_info *panssenger_info)$/;"	f
APid	newmain.c	/^char APid[22];$/;"	v
B0	newmain.c	55;"	d	file:
B1	newmain.c	56;"	d	file:
B2	newmain.c	57;"	d	file:
B3	newmain.c	58;"	d	file:
BOYI_APP_VERSION	newmain.c	/^char BOYI_APP_VERSION[31];$/;"	v
Big_Little	newmain.c	60;"	d	file:
CC	Makefile	/^CC=mips-linux-gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS=-I..\/include -I.\/ -L..\/cJSON\/ -I..\/cJSON\/$/;"	m
CGILDFLAGS	Makefile	/^CGILDFLAGS=$(LDFLAGS)$/;"	m
COLLECT_AP_CHANNEL	info.h	/^	LON = 1,LAT,SSID,HIS_CTIME,CRC,COLLECT_AP_SSID,COLLECT_AP_MAC,COLLECT_AP_CHANNEL,COLLECT_AP_ENCRYPT_TYPE,DEV_ADDR$/;"	e	enum:SUB_DATA_TYPE
COLLECT_AP_ENCRYPT_TYPE	info.h	/^	LON = 1,LAT,SSID,HIS_CTIME,CRC,COLLECT_AP_SSID,COLLECT_AP_MAC,COLLECT_AP_CHANNEL,COLLECT_AP_ENCRYPT_TYPE,DEV_ADDR$/;"	e	enum:SUB_DATA_TYPE
COLLECT_AP_MAC	info.h	/^	LON = 1,LAT,SSID,HIS_CTIME,CRC,COLLECT_AP_SSID,COLLECT_AP_MAC,COLLECT_AP_CHANNEL,COLLECT_AP_ENCRYPT_TYPE,DEV_ADDR$/;"	e	enum:SUB_DATA_TYPE
COLLECT_AP_SSID	info.h	/^	LON = 1,LAT,SSID,HIS_CTIME,CRC,COLLECT_AP_SSID,COLLECT_AP_MAC,COLLECT_AP_CHANNEL,COLLECT_AP_ENCRYPT_TYPE,DEV_ADDR$/;"	e	enum:SUB_DATA_TYPE
COPY_STR2MAC	newmain.c	171;"	d	file:
CRC	info.h	/^	LON = 1,LAT,SSID,HIS_CTIME,CRC,COLLECT_AP_SSID,COLLECT_AP_MAC,COLLECT_AP_CHANNEL,COLLECT_AP_ENCRYPT_TYPE,DEV_ADDR$/;"	e	enum:SUB_DATA_TYPE
Cap_data	info.h	/^}Cap_data;$/;"	t	typeref:struct:_cap_data
Cap_manager	info.h	/^}Cap_manager;$/;"	t	typeref:struct:_cap_manager
Cap_sub_data	info.h	/^}Cap_sub_data;$/;"	t	typeref:struct:_cap_sub_data
CenterIP	newmain.c	/^char CenterIP[20];$/;"	v
DATA_COUNT_MAX	newmain.c	50;"	d	file:
DEV_ADDR	info.h	/^	LON = 1,LAT,SSID,HIS_CTIME,CRC,COLLECT_AP_SSID,COLLECT_AP_MAC,COLLECT_AP_CHANNEL,COLLECT_AP_ENCRYPT_TYPE,DEV_ADDR$/;"	e	enum:SUB_DATA_TYPE
FTP_DATA	newmain.c	67;"	d	file:
HIS_CTIME	info.h	/^	LON = 1,LAT,SSID,HIS_CTIME,CRC,COLLECT_AP_SSID,COLLECT_AP_MAC,COLLECT_AP_CHANNEL,COLLECT_AP_ENCRYPT_TYPE,DEV_ADDR$/;"	e	enum:SUB_DATA_TYPE
HLIST_HEAD	list.h	569;"	d
HLIST_HEAD_INIT	list.h	568;"	d
Head_data	info.h	/^}Head_data;$/;"	t	typeref:struct:_head_data
INIT_HLIST_HEAD	list.h	570;"	d
INIT_HLIST_NODE	list.h	/^static inline void INIT_HLIST_NODE(struct hlist_node *h)$/;"	f
INIT_LIST_HEAD	list.h	/^static inline void INIT_LIST_HEAD(struct list_head *list)$/;"	f
Info_manager	info.h	/^}Info_manager;$/;"	t	typeref:struct:_info_manager
LAT	info.h	/^	LON = 1,LAT,SSID,HIS_CTIME,CRC,COLLECT_AP_SSID,COLLECT_AP_MAC,COLLECT_AP_CHANNEL,COLLECT_AP_ENCRYPT_TYPE,DEV_ADDR$/;"	e	enum:SUB_DATA_TYPE
LIBS	Makefile	/^LIBS = -lpthread -ldl #-lcom -liw$/;"	m
LIST_HEAD	list.h	27;"	d
LIST_HEAD_INIT	list.h	25;"	d
LIST_POISON1	list.h	8;"	d
LIST_POISON2	list.h	9;"	d
LON	info.h	/^	LON = 1,LAT,SSID,HIS_CTIME,CRC,COLLECT_AP_SSID,COLLECT_AP_MAC,COLLECT_AP_CHANNEL,COLLECT_AP_ENCRYPT_TYPE,DEV_ADDR$/;"	e	enum:SUB_DATA_TYPE
MAC_LEN_IN_BYTE	newmain.c	170;"	d	file:
MAX_JSON_NUM	info.h	13;"	d
MAX_SUB_DATA_NUM	info.h	14;"	d
NULL	list.h	5;"	d
OBJS	Makefile	/^OBJS= newmain.o cJSON.o get_file_config.o $/;"	m
Panssenger_info	info.h	/^}Panssenger_info; $/;"	t	typeref:struct:_passigner_info
RAW_PACKAGE	newmain.c	52;"	d	file:
ReadConf	newmain.c	/^void ReadConf()$/;"	f
SEND_BUFF_SIZE	newmain.c	44;"	d	file:
SERVER_DATA_PORT	newmain.c	/^unsigned int SERVER_DATA_PORT = 18190;$/;"	v
SNF_ARRY_SIZE	newmain.c	45;"	d	file:
SNF_BUF_SIZE	newmain.c	46;"	d	file:
SOURCE	newmain.c	/^char SOURCE[3];$/;"	v
SSID	info.h	/^	LON = 1,LAT,SSID,HIS_CTIME,CRC,COLLECT_AP_SSID,COLLECT_AP_MAC,COLLECT_AP_CHANNEL,COLLECT_AP_ENCRYPT_TYPE,DEV_ADDR$/;"	e	enum:SUB_DATA_TYPE
SUB_DATA_TYPE	info.h	/^enum SUB_DATA_TYPE$/;"	g
USER_CHECK_IN_PORT	newmain.c	49;"	d	file:
USER_LOGIN_PORT	newmain.c	48;"	d	file:
UniqID	newmain.c	/^unsigned int UniqID = 0;$/;"	v
UniqID_two	newmain.c	/^unsigned int UniqID_two = 0;$/;"	v
UnitCode	newmain.c	/^char UnitCode[20];$/;"	v
_GNU_SOURCE	get_file_config.c	5;"	d	file:
_LINUX_LIST_H	list.h	2;"	d
__GET_FILE_CONFIG_H__	get_file_config.h	2;"	d
__hlist_del	list.h	/^static inline void __hlist_del(struct hlist_node *n)$/;"	f
__list_add	list.h	/^static inline void __list_add(struct list_head *new,$/;"	f
__list_cut_position	list.h	/^static inline void __list_cut_position(struct list_head *list,$/;"	f
__list_del	list.h	/^static inline void __list_del(struct list_head * prev, struct list_head * next)$/;"	f
__list_for_each	list.h	387;"	d
__list_splice	list.h	/^static inline void __list_splice(const struct list_head *list,$/;"	f
_cap_data	info.h	/^typedef struct _cap_data$/;"	s
_cap_manager	info.h	/^typedef struct _cap_manager $/;"	s
_cap_sub_data	info.h	/^typedef struct _cap_sub_data$/;"	s
_head_data	info.h	/^typedef struct _head_data$/;"	s
_info_manager	info.h	/^typedef struct _info_manager $/;"	s
_passigner_info	info.h	/^typedef struct _passigner_info$/;"	s
a2x	newmain.c	/^unsigned char a2x(const char c)$/;"	f
analysis_pack	newmain.c	/^void analysis_pack(unsigned char* recvmsg, int size)$/;"	f
ap_count	newmain.c	/^static int ap_count = 0;$/;"	v	file:
ap_toal	newmain.c	/^unsigned long int ap_toal =0 ;$/;"	v
buffer	cJSON.c	/^typedef struct {char *buffer; int length; int offset; } printbuffer;$/;"	m	struct:__anon1	file:
buffer	info.h	/^   unsigned char *buffer;$/;"	m	struct:sniffer_data
cJSON	cJSON.h	/^typedef struct cJSON {$/;"	s
cJSON	cJSON.h	/^} cJSON;$/;"	t	typeref:struct:cJSON
cJSON_AddBoolToObject	cJSON.h	137;"	d
cJSON_AddFalseToObject	cJSON.h	136;"	d
cJSON_AddItemReferenceToArray	cJSON.c	/^void	cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)						{cJSON_AddItemToArray(array,create_reference(item));}$/;"	f
cJSON_AddItemReferenceToObject	cJSON.c	/^void	cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item)	{cJSON_AddItemToObject(object,string,create_reference(item));}$/;"	f
cJSON_AddItemToArray	cJSON.c	/^void   cJSON_AddItemToArray(cJSON *array, cJSON *item)						{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}$/;"	f
cJSON_AddItemToObject	cJSON.c	/^void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}$/;"	f
cJSON_AddItemToObjectCS	cJSON.c	/^void   cJSON_AddItemToObjectCS(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (!(item->type&cJSON_StringIsConst) && item->string) cJSON_free(item->string);item->string=(char*)string;item->type|=cJSON_StringIsConst;cJSON_AddItemToArray(object,item);}$/;"	f
cJSON_AddNullToObject	cJSON.h	134;"	d
cJSON_AddNumberToObject	cJSON.h	138;"	d
cJSON_AddStringToObject	cJSON.h	139;"	d
cJSON_AddTrueToObject	cJSON.h	135;"	d
cJSON_Array	cJSON.h	37;"	d
cJSON_CreateArray	cJSON.c	/^cJSON *cJSON_CreateArray(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}$/;"	f
cJSON_CreateBool	cJSON.c	/^cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}$/;"	f
cJSON_CreateDoubleArray	cJSON.c	/^cJSON *cJSON_CreateDoubleArray(const double *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f
cJSON_CreateFalse	cJSON.c	/^cJSON *cJSON_CreateFalse(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}$/;"	f
cJSON_CreateFloatArray	cJSON.c	/^cJSON *cJSON_CreateFloatArray(const float *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f
cJSON_CreateIntArray	cJSON.c	/^cJSON *cJSON_CreateIntArray(const int *numbers,int count)		{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f
cJSON_CreateNull	cJSON.c	/^cJSON *cJSON_CreateNull(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}$/;"	f
cJSON_CreateNumber	cJSON.c	/^cJSON *cJSON_CreateNumber(double num)			{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int)num;}return item;}$/;"	f
cJSON_CreateObject	cJSON.c	/^cJSON *cJSON_CreateObject(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}$/;"	f
cJSON_CreateString	cJSON.c	/^cJSON *cJSON_CreateString(const char *string)	{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);}return item;}$/;"	f
cJSON_CreateStringArray	cJSON.c	/^cJSON *cJSON_CreateStringArray(const char **strings,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f
cJSON_CreateTrue	cJSON.c	/^cJSON *cJSON_CreateTrue(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}$/;"	f
cJSON_Delete	cJSON.c	/^void cJSON_Delete(cJSON *c)$/;"	f
cJSON_DeleteItemFromArray	cJSON.c	/^void   cJSON_DeleteItemFromArray(cJSON *array,int which)			{cJSON_Delete(cJSON_DetachItemFromArray(array,which));}$/;"	f
cJSON_DeleteItemFromObject	cJSON.c	/^void   cJSON_DeleteItemFromObject(cJSON *object,const char *string) {cJSON_Delete(cJSON_DetachItemFromObject(object,string));}$/;"	f
cJSON_DetachItemFromArray	cJSON.c	/^cJSON *cJSON_DetachItemFromArray(cJSON *array,int which)			{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return 0;$/;"	f
cJSON_DetachItemFromObject	cJSON.c	/^cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string) {int i=0;cJSON *c=object->child;while (c && cJSON_strcasecmp(c->string,string)) i++,c=c->next;if (c) return cJSON_DetachItemFromArray(object,i);return 0;}$/;"	f
cJSON_Duplicate	cJSON.c	/^cJSON *cJSON_Duplicate(cJSON *item,int recurse)$/;"	f
cJSON_False	cJSON.h	32;"	d
cJSON_GetArrayItem	cJSON.c	/^cJSON *cJSON_GetArrayItem(cJSON *array,int item)				{cJSON *c=array->child;  while (c && item>0) item--,c=c->next; return c;}$/;"	f
cJSON_GetArraySize	cJSON.c	/^int    cJSON_GetArraySize(cJSON *array)							{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}$/;"	f
cJSON_GetErrorPtr	cJSON.c	/^const char *cJSON_GetErrorPtr(void) {return ep;}$/;"	f
cJSON_GetObjectItem	cJSON.c	/^cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)	{cJSON *c=object->child; while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}$/;"	f
cJSON_Hooks	cJSON.h	/^typedef struct cJSON_Hooks {$/;"	s
cJSON_Hooks	cJSON.h	/^} cJSON_Hooks;$/;"	t	typeref:struct:cJSON_Hooks
cJSON_InitHooks	cJSON.c	/^void cJSON_InitHooks(cJSON_Hooks* hooks)$/;"	f
cJSON_InsertItemInArray	cJSON.c	/^void   cJSON_InsertItemInArray(cJSON *array,int which,cJSON *newitem)		{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) {cJSON_AddItemToArray(array,newitem);return;}$/;"	f
cJSON_IsReference	cJSON.h	40;"	d
cJSON_Minify	cJSON.c	/^void cJSON_Minify(char *json)$/;"	f
cJSON_NULL	cJSON.h	34;"	d
cJSON_New_Item	cJSON.c	/^static cJSON *cJSON_New_Item(void)$/;"	f	file:
cJSON_Number	cJSON.h	35;"	d
cJSON_Object	cJSON.h	38;"	d
cJSON_Parse	cJSON.c	/^cJSON *cJSON_Parse(const char *value) {return cJSON_ParseWithOpts(value,0,0);}$/;"	f
cJSON_ParseWithOpts	cJSON.c	/^cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated)$/;"	f
cJSON_Print	cJSON.c	/^char *cJSON_Print(cJSON *item)				{return print_value(item,0,1,0);}$/;"	f
cJSON_PrintBuffered	cJSON.c	/^char *cJSON_PrintBuffered(cJSON *item,int prebuffer,int fmt)$/;"	f
cJSON_PrintUnformatted	cJSON.c	/^char *cJSON_PrintUnformatted(cJSON *item)	{return print_value(item,0,0,0);}$/;"	f
cJSON_ReplaceItemInArray	cJSON.c	/^void   cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem)		{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return;$/;"	f
cJSON_ReplaceItemInObject	cJSON.c	/^void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}$/;"	f
cJSON_SetIntValue	cJSON.h	142;"	d
cJSON_SetNumberValue	cJSON.h	143;"	d
cJSON_String	cJSON.h	36;"	d
cJSON_StringIsConst	cJSON.h	41;"	d
cJSON_True	cJSON.h	33;"	d
cJSON__h	cJSON.h	24;"	d
cJSON_free	cJSON.c	/^static void (*cJSON_free)(void *ptr) = free;$/;"	v	file:
cJSON_malloc	cJSON.c	/^static void *(*cJSON_malloc)(size_t sz) = malloc;$/;"	v	file:
cJSON_strcasecmp	cJSON.c	/^static int cJSON_strcasecmp(const char *s1,const char *s2)$/;"	f	file:
cJSON_strdup	cJSON.c	/^static char* cJSON_strdup(const char* str)$/;"	f	file:
cap_data	info.h	/^	Cap_data cap_data;$/;"	m	struct:_cap_manager
cap_data	info.h	/^	Cap_data cap_data;$/;"	m	struct:_passigner_info
cap_sub_data	info.h	/^	Cap_sub_data cap_sub_data[MAX_SUB_DATA_NUM];$/;"	m	struct:_cap_manager
cap_sub_data	info.h	/^	Cap_sub_data cap_sub_data[MAX_SUB_DATA_NUM];$/;"	m	struct:_passigner_info
cap_time	info.h	/^	unsigned long cap_time; \/\/时间戳$/;"	m	struct:_cap_data
capture_flag	get_file_config.h	/^	int capture_flag;$/;"	m	struct:recv_mac
capture_time	get_file_config.h	/^	char capture_time[20];$/;"	m	struct:recv_mac
cattime	info.h	/^   time_t cattime;$/;"	m	struct:sniffer_data
child	cJSON.h	/^	struct cJSON *child;		\/* An array or object item will have a child pointer pointing to a chain of the items in the array\/object. *\/$/;"	m	struct:cJSON	typeref:struct:cJSON::cJSON
container_of	list.h	344;"	d
content_data	info.h	/^	unsigned char *content_data;$/;"	m	struct:_cap_sub_data
create_reference	cJSON.c	/^static cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}$/;"	f	file:
data_length	info.h	/^	unsigned long data_length; \/\/数据域长度 N$/;"	m	struct:_head_data
data_size	info.h	/^   int data_size; \/\/ recv data size$/;"	m	struct:sniffer_data
data_type	info.h	/^    unsigned short data_type;   \/\/03：TAG采集 04：MAC采集 05：虚拟身份采集$/;"	m	struct:_head_data
deleteALL	get_file_config.c	/^void deleteALL(struct recv_mac **p_head)$/;"	f
der_data	newmain.c	/^void der_data(Panssenger_info * data)$/;"	f
der_virtual_data	newmain.c	/^void der_virtual_data(Panssenger_info * data)$/;"	f
device_flag	info.h	/^	unsigned char  device_flag[6]; \/\/探针MAC$/;"	m	struct:_head_data
doc_version	newmain.c	/^char doc_version[32]  = {'\\0'};$/;"	v
ensure	cJSON.c	/^static char* ensure(printbuffer *p,int needed)$/;"	f	file:
ep	cJSON.c	/^static const char *ep;$/;"	v	file:
fill_sub_info	newmain.c	/^void fill_sub_info(Panssenger_info *panssenger_info,unsigned short type,unsigned short len,char * data)$/;"	f
first	list.h	/^	struct hlist_node *first;$/;"	m	struct:hlist_head	typeref:struct:hlist_head::hlist_node
firstByteMark	cJSON.c	/^static const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };$/;"	v	file:
free_fn	cJSON.h	/^      void (*free_fn)(void *ptr);$/;"	m	struct:cJSON_Hooks
get_config	get_file_config.c	/^int get_config(char *path,char *key, char *value)\/\/从config.txt中获取配置信息 yl修改，修改之后配置文件只有config.txt,升级包带版本versionLoad.txt$/;"	f
get_text_data	get_file_config.c	/^int get_text_data(char* src,char* start,char* end,char* target,int limit)$/;"	f
get_vitual_type	newmain.c	/^char* get_vitual_type(char* local_type)$/;"	f
head	info.h	/^	struct list_head head;$/;"	m	struct:_cap_manager	typeref:struct:_cap_manager::list_head
head	info.h	/^	struct list_head head;$/;"	m	struct:_info_manager	typeref:struct:_info_manager::list_head
head_data	info.h	/^	Head_data head_data;$/;"	m	struct:_cap_manager
head_data	info.h	/^	Head_data head_data;$/;"	m	struct:_info_manager
head_data	info.h	/^	Head_data head_data;$/;"	m	struct:_passigner_info
head_len	newmain.c	/^int	head_len = 14;$/;"	v
hlist_add_after	list.h	/^static inline void hlist_add_after(struct hlist_node *n,$/;"	f
hlist_add_before	list.h	/^static inline void hlist_add_before(struct hlist_node *n,$/;"	f
hlist_add_head	list.h	/^static inline void hlist_add_head(struct hlist_node *n, struct hlist_head *h)$/;"	f
hlist_del	list.h	/^static inline void hlist_del(struct hlist_node *n)$/;"	f
hlist_del_init	list.h	/^static inline void hlist_del_init(struct hlist_node *n)$/;"	f
hlist_empty	list.h	/^static inline int hlist_empty(const struct hlist_head *h)$/;"	f
hlist_entry	list.h	655;"	d
hlist_for_each	list.h	657;"	d
hlist_for_each_entry	list.h	672;"	d
hlist_for_each_entry_continue	list.h	684;"	d
hlist_for_each_entry_from	list.h	696;"	d
hlist_for_each_entry_safe	list.h	709;"	d
hlist_for_each_safe	list.h	661;"	d
hlist_head	list.h	/^struct hlist_head {$/;"	s
hlist_move_list	list.h	/^static inline void hlist_move_list(struct hlist_head *old,$/;"	f
hlist_node	list.h	/^struct hlist_node {$/;"	s
hlist_unhashed	list.h	/^static inline int hlist_unhashed(const struct hlist_node *h)$/;"	f
hostToIp	newmain.c	/^int hostToIp(char *hostname,char *ip_config)$/;"	f
id	newmain.c	/^	char id[128];$/;"	m	struct:virtual_true_type	file:
id_type	newmain.c	/^	char id_type[16];$/;"	m	struct:virtual_true_type	file:
js_arr	info.h	/^	cJSON *js_arr[MAX_JSON_NUM];$/;"	m	struct:_info_manager
js_num	info.h	/^	int js_num;$/;"	m	struct:_info_manager
latde	newmain.c	/^char latde[12];$/;"	v
latde_get	newmain.c	/^char latde_get[12];$/;"	v
length	cJSON.c	/^typedef struct {char *buffer; int length; int offset; } printbuffer;$/;"	m	struct:__anon1	file:
link_creat_head_check	get_file_config.c	/^void link_creat_head_check( struct recv_mac **p_head, struct recv_mac *p_new)$/;"	f
link_search_mac_check	get_file_config.c	/^struct recv_mac * link_search_mac_check( struct recv_mac *head,char *mac)$/;"	f
list_add_head	list.h	/^static inline void list_add_head(struct list_head *new, struct list_head *head)$/;"	f
list_add_tail	list.h	/^static inline void list_add_tail(struct list_head *new, struct list_head *head)$/;"	f
list_cut_position	list.h	/^static inline void list_cut_position(struct list_head *list,$/;"	f
list_del	list.h	/^static inline void list_del(struct list_head *entry)$/;"	f
list_del_init	list.h	/^static inline void list_del_init(struct list_head *entry)$/;"	f
list_empty	list.h	/^static inline int list_empty(const struct list_head *head)$/;"	f
list_empty_careful	list.h	/^static inline int list_empty_careful(const struct list_head *head)$/;"	f
list_entry	list.h	354;"	d
list_first_entry	list.h	365;"	d
list_for_each	list.h	373;"	d
list_for_each_entry	list.h	426;"	d
list_for_each_entry_continue	list.h	462;"	d
list_for_each_entry_continue_reverse	list.h	476;"	d
list_for_each_entry_from	list.h	489;"	d
list_for_each_entry_reverse	list.h	437;"	d
list_for_each_entry_safe	list.h	500;"	d
list_for_each_entry_safe_continue	list.h	516;"	d
list_for_each_entry_safe_from	list.h	532;"	d
list_for_each_entry_safe_reverse	list.h	547;"	d
list_for_each_prev	list.h	395;"	d
list_for_each_prev_safe	list.h	415;"	d
list_for_each_safe	list.h	405;"	d
list_head	list.h	/^struct list_head {$/;"	s
list_is_last	list.h	/^static inline int list_is_last(const struct list_head *list,$/;"	f
list_is_singular	list.h	/^static inline int list_is_singular(const struct list_head *head)$/;"	f
list_move	list.h	/^static inline void list_move(struct list_head *list, struct list_head *head)$/;"	f
list_move_tail	list.h	/^static inline void list_move_tail(struct list_head *list,$/;"	f
list_prepare_entry	list.h	450;"	d
list_replace	list.h	/^static inline void list_replace(struct list_head *old,$/;"	f
list_replace_init	list.h	/^static inline void list_replace_init(struct list_head *old,$/;"	f
list_splice	list.h	/^static inline void list_splice(const struct list_head *list,$/;"	f
list_splice_init	list.h	/^static inline void list_splice_init(struct list_head *list,$/;"	f
list_splice_tail	list.h	/^static inline void list_splice_tail(struct list_head *list,$/;"	f
list_splice_tail_init	list.h	/^static inline void list_splice_tail_init(struct list_head *list,$/;"	f
lnglat_mx_sort	newmain.c	/^pthread_mutex_t  lnglat_mx_sort;$/;"	v
local_type	newmain.c	/^	char local_type[10];$/;"	m	struct:virtual_type	file:
locator_dev_type	newmain.c	/^char locator_dev_type[2] = {'\\0'};$/;"	v
locator_site_type	newmain.c	/^char locator_site_type[3];$/;"	v
longde	newmain.c	/^char longde[12];$/;"	v
longde_get	newmain.c	/^char longde_get[12];$/;"	v
mac_head	newmain.c	/^struct recv_mac *mac_head ;$/;"	v	typeref:struct:recv_mac
mac_mx_sort	newmain.c	/^pthread_mutex_t  mac_mx_sort;$/;"	v
main	newmain.c	/^int main(int argc, char **argv)$/;"	f
make_mac_del_colon	newmain.c	/^void make_mac_del_colon(char *mac,char *mac_t)$/;"	f
malloc_fn	cJSON.h	/^      void *(*malloc_fn)(size_t sz);$/;"	m	struct:cJSON_Hooks
malloc_sniffer_buffer	newmain.c	/^int malloc_sniffer_buffer(struct sniffer_data* sniffer_data, int arry_size)$/;"	f
modify_text	get_file_config.c	/^void modify_text(char *path,char *start,char *end,char *data)$/;"	f
mutex	info.h	/^   pthread_mutex_t mutex;$/;"	m	struct:sniffer_data
mymutex	newmain.c	/^pthread_mutex_t mymutex = PTHREAD_MUTEX_INITIALIZER; \/*互斥锁*\/$/;"	v
network_card	newmain.c	/^char network_card[12];$/;"	v
next	cJSON.h	/^	struct cJSON *next,*prev;	\/* next\/prev allow you to walk array\/object chains. Alternatively, use GetArraySize\/GetArrayItem\/GetObjectItem *\/$/;"	m	struct:cJSON	typeref:struct:cJSON::cJSON
next	get_file_config.h	/^	struct recv_mac *next;$/;"	m	struct:recv_mac	typeref:struct:recv_mac::recv_mac
next	list.h	/^	struct hlist_node *next, **pprev;$/;"	m	struct:hlist_node	typeref:struct:hlist_node::hlist_node
next	list.h	/^	struct list_head *next, *prev;$/;"	m	struct:list_head	typeref:struct:list_head::list_head
offset	cJSON.c	/^typedef struct {char *buffer; int length; int offset; } printbuffer;$/;"	m	struct:__anon1	file:
offsetof	list.h	337;"	d
offsetof	list.h	339;"	d
offsetof	list.h	341;"	d
packet_need_to_deal	newmain.c	/^unsigned int packet_need_to_deal = 0;$/;"	v
parse_array	cJSON.c	/^static const char *parse_array(cJSON *item,const char *value)$/;"	f	file:
parse_hex4	cJSON.c	/^static unsigned parse_hex4(const char *str)$/;"	f	file:
parse_number	cJSON.c	/^static const char *parse_number(cJSON *item,const char *num)$/;"	f	file:
parse_object	cJSON.c	/^static const char *parse_object(cJSON *item,const char *value)$/;"	f	file:
parse_string	cJSON.c	/^static const char *parse_string(cJSON *item,const char *str)$/;"	f	file:
parse_value	cJSON.c	/^static const char *parse_value(cJSON *item,const char *value)$/;"	f	file:
pow2gt	cJSON.c	/^static int pow2gt (int x)	{	--x;	x|=x>>1;	x|=x>>2;	x|=x>>4;	x|=x>>8;	x|=x>>16;	return x+1;	}$/;"	f	file:
pprev	list.h	/^	struct hlist_node *next, **pprev;$/;"	m	struct:hlist_node	typeref:struct:hlist_node::
prev	cJSON.h	/^	struct cJSON *next,*prev;	\/* next\/prev allow you to walk array\/object chains. Alternatively, use GetArraySize\/GetArrayItem\/GetObjectItem *\/$/;"	m	struct:cJSON	typeref:struct:cJSON::
prev	list.h	/^	struct list_head *next, *prev;$/;"	m	struct:list_head	typeref:struct:list_head::
print_array	cJSON.c	/^static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p)$/;"	f	file:
print_data	newmain.c	/^void print_data(Panssenger_info * data)$/;"	f
print_number	cJSON.c	/^static char *print_number(cJSON *item,printbuffer *p)$/;"	f	file:
print_object	cJSON.c	/^static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p)$/;"	f	file:
print_string	cJSON.c	/^static char *print_string(cJSON *item,printbuffer *p)	{return print_string_ptr(item->valuestring,p);}$/;"	f	file:
print_string_ptr	cJSON.c	/^static char *print_string_ptr(const char *str,printbuffer *p)$/;"	f	file:
print_value	cJSON.c	/^static char *print_value(cJSON *item,int depth,int fmt,printbuffer *p)$/;"	f	file:
printbuffer	cJSON.c	/^typedef struct {char *buffer; int length; int offset; } printbuffer;$/;"	t	typeref:struct:__anon1	file:
printf_info	newmain.c	/^int printf_info = 0;$/;"	v
province_code	newmain.c	/^char province_code[7]  = {'\\0'};$/;"	v
qzt_type	newmain.c	/^	char qzt_type[10];$/;"	m	struct:virtual_type	file:
recv_mac	get_file_config.h	/^struct recv_mac$/;"	s
run_stop	newmain.c	/^short int run_stop =0;$/;"	v
security_vendor_code	newmain.c	/^char security_vendor_code[10];$/;"	v
send_data	newmain.c	/^char send_data[1514] = "";$/;"	v
send_data_time	newmain.c	/^unsigned long  send_data_time = 0;$/;"	v
send_data_toal	newmain.c	/^unsigned long  send_data_toal = 0;$/;"	v
send_flag	get_file_config.h	/^	int send_flag;$/;"	m	struct:recv_mac
send_mac	get_file_config.h	/^	char send_mac[18];$/;"	m	struct:recv_mac
send_mode	newmain.c	/^char send_mode[10] = "";$/;"	v
send_tcp	newmain.c	/^void send_tcp(char *ip_str, int port)$/;"	f
sendtrack_time	newmain.c	/^int  sendtrack_time = 600;$/;"	v
set_config	get_file_config.c	/^void set_config(char *path,char *key,char *value)$/;"	f
skip	cJSON.c	/^static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}$/;"	f	file:
snf_data_arry	newmain.c	/^struct sniffer_data snf_data_arry[SNF_ARRY_SIZE];$/;"	v	typeref:struct:sniffer_data
sniffer_data	info.h	/^struct sniffer_data$/;"	s
sniffer_data_deal	newmain.c	/^void sniffer_data_deal(void *arg)$/;"	f
sta_count	newmain.c	/^static int sta_count = 0;$/;"	v	file:
sta_toal	newmain.c	/^unsigned long int sta_toal =0 ;$/;"	v
start_sniffer_data_deal	newmain.c	/^void start_sniffer_data_deal()$/;"	f
string	cJSON.h	/^	char *string;				\/* The item's name string, if this item is the child of, or is in the list of subitems of an object. *\/$/;"	m	struct:cJSON
sub_data_len	info.h	/^	unsigned short sub_data_len;$/;"	m	struct:_cap_sub_data
sub_data_num	info.h	/^	int sub_data_num;$/;"	m	struct:_cap_manager
sub_data_num	info.h	/^	int sub_data_num;$/;"	m	struct:_passigner_info
sub_type	info.h	/^	unsigned short sub_type;\/\/MAC数据类型： 0：MAC数据$/;"	m	struct:_cap_data
sub_type	info.h	/^    unsigned short sub_type;$/;"	m	struct:_cap_sub_data
suffix_object	cJSON.c	/^static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}$/;"	f	file:
term_mac	info.h	/^    unsigned char term_mac[6];$/;"	m	struct:_cap_data
term_signal	info.h	/^    unsigned char term_signal[2];$/;"	m	struct:_cap_data
term_type	info.h	/^	unsigned short term_type;\/\/0：表示未能识别终端类型，1：无线帧来自STA，2：无线帧来自AP ,3: 无线帧来自TAG.$/;"	m	struct:_cap_data
type	cJSON.h	/^	int type;					\/* The type of the item, as above. *\/$/;"	m	struct:cJSON
type	info.h	/^   int type;$/;"	m	struct:sniffer_data
update	cJSON.c	/^static int update(printbuffer *p)$/;"	f	file:
valuedouble	cJSON.h	/^	double valuedouble;			\/* The item's number, if type==cJSON_Number *\/$/;"	m	struct:cJSON
valueint	cJSON.h	/^	int valueint;				\/* The item's number, if type==cJSON_Number *\/$/;"	m	struct:cJSON
valuestring	cJSON.h	/^	char *valuestring;			\/* The item's string, if type==cJSON_String *\/$/;"	m	struct:cJSON
version	info.h	/^	unsigned short version;       \/\/协议版本号$/;"	m	struct:_head_data
virtual_info	info.h	/^	cJSON *virtual_info;$/;"	m	struct:_passigner_info
virtual_toal	newmain.c	/^unsigned long int virtual_toal = 0;$/;"	v
virtual_true_type	newmain.c	/^struct virtual_true_type$/;"	s	file:
virtual_type	newmain.c	/^struct virtual_type$/;"	s	file:
virtual_types	newmain.c	/^struct virtual_type virtual_types[] = $/;"	v	typeref:struct:virtual_type
